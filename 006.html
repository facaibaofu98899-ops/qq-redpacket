<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QQ手气红包尾数预测系统 - 综合增强版</title>
    <script src="https://unpkg.com/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        .upload-float-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
            cursor: pointer;
            z-index: 1000;
            transition: transform 0.3s;
        }
        
        .upload-float-btn:hover {
            transform: scale(1.1);
        }
        
        .upload-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
            padding: 20px;
        }
        
        .upload-content {
            background: white;
            padding: 20px;
            border-radius: 15px;
            width: 95%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .section {
            padding: 20px;
            border-bottom: 1px solid #eee;
        }
        
        .result-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #667eea;
        }
        
        .tail-number {
            display: inline-block;
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 40px;
            margin: 5px;
            font-weight: bold;
        }
        
        .confidence-high { color: #2ecc71; font-weight: bold; }
        .confidence-medium { color: #f39c12; font-weight: bold; }
        .confidence-low { color: #e74c3c; font-weight: bold; }
        
        .history-item {
            background: #f8f9fa;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 3px solid #667eea;
        }
        
        .correct-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            margin-left: 10px;
        }
        
        .chart-container {
            height: 200px;
            margin: 20px 0;
        }
        
        .prediction-result {
            text-align: center;
            padding: 20px;
            background: linear-gradient(135deg, #a8edea, #fed6e3);
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .image-preview-container {
            position: relative;
            margin: 15px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
            overflow: hidden;
            max-width: 100%;
            max-height: 400px;
            overflow: auto;
        }
        
        #imagePreview {
            max-width: 100%;
            display: block;
        }
        
        .selection-box {
            position: absolute;
            border: 2px solid #ff6b6b;
            background-color: rgba(255, 107, 107, 0.1);
            pointer-events: none;
        }
        
        .selection-label {
            position: absolute;
            top: -25px;
            left: 0;
            background: #ff6b6b;
            color: white;
            padding: 2px 8px;
            font-size: 12px;
            border-radius: 3px;
        }
        
        .control-panel {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
        }
        
        .control-group {
            margin: 15px 0;
        }
        
        .control-group h4 {
            margin-bottom: 10px;
            color: #333;
            padding-bottom: 5px;
            border-bottom: 1px solid #ddd;
        }
        
        .slider-container {
            margin: 10px 0;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .slider-label span {
            font-size: 14px;
            color: #555;
        }
        
        .slider {
            -webkit-appearance: none;
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background: #d3d3d3;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }
        
        .tab-buttons {
            display: flex;
            margin-bottom: 10px;
            border-bottom: 1px solid #ddd;
            flex-wrap: wrap;
        }
        
        .tab-button {
            padding: 10px 15px;
            background: #f0f0f0;
            border: none;
            cursor: pointer;
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
            font-size: 14px;
            flex: 1;
            min-width: 120px;
            text-align: center;
        }
        
        .tab-button.active {
            background: #667eea;
            color: white;
        }
        
        .tab-content {
            display: none;
            padding: 15px;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 5px 5px;
        }
        
        .tab-content.active {
            display: block;
        }
        
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        
        button:hover {
            background: #2980b9;
        }
        
        button.danger {
            background: #e74c3c;
        }
        
        button.danger:hover {
            background: #c0392b;
        }
        
        button.success {
            background: #2ecc71;
        }
        
        button.success:hover {
            background: #27ae60;
        }
        
        .status-message {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            background: #f8f9fa;
            border-left: 4px solid #3498db;
        }
        
        .status-message.error {
            border-left-color: #e74c3c;
            background: #ffeaea;
        }
        
        .status-message.success {
            border-left-color: #2ecc71;
            background: #eaffea;
        }
        
        .manual-input {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
        }
        
        .manual-input h4 {
            margin-bottom: 10px;
        }
        
        .amount-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }
        
        .amount-input {
            display: flex;
            align-items: center;
        }
        
        .amount-input label {
            width: 60px;
            margin-right: 5px;
        }
        
        .amount-input input {
            width: 80px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        
        .preset-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 10px 0;
        }
        
        .preset-button {
            background: #9b59b6;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .preset-button:hover {
            background: #8e44ad;
        }
        
        /* 新增样式 - 从加强版中提取 */
        .enhanced-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
        }
        
        .enhanced-controls button {
            flex: 1;
            min-width: 140px;
        }
        
        .progress-bar {
            height: 6px;
            background: #f0f0f0;
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress {
            height: 100%;
            background: #4CAF50;
            width: 0%;
            transition: width 0.3s;
        }
        
        .accuracy-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            margin-left: 8px;
        }
        
        .high-accuracy {
            background: #e8f5e9;
            color: #2e7d32;
        }
        
        .medium-accuracy {
            background: #fff8e1;
            color: #f57c00;
        }
        
        .low-accuracy {
            background: #ffebee;
            color: #d32f2f;
        }
        
        .auto-mode {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        
        .auto-mode label {
            margin-left: 8px;
        }
        
        .amount-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .amount-item:last-child {
            border-bottom: none;
        }
        
        .amount-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
        }
        
        @media (max-width: 600px) {
            .tab-button {
                min-width: 100px;
                padding: 8px 10px;
                font-size: 12px;
            }
            
            .amount-inputs {
                grid-template-columns: 1fr;
            }
            
            .preset-buttons {
                flex-direction: column;
            }
            
            .enhanced-controls button {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <!-- 浮动上传按钮 -->
    <div class="upload-float-btn" onclick="openUploadModal()">
        📷
    </div>

    <!-- 上传模态框 -->
    <div class="upload-modal" id="uploadModal">
        <div class="upload-content">
            <h3>QQ红包数据录入系统 - 增强版</h3>
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab('uploadTab')">上传截图</button>
                <button class="tab-button" onclick="switchTab('adjustTab')">区域调整</button>
                <button class="tab-button" onclick="switchTab('manualTab')">手动输入</button>
                <button class="tab-button" onclick="switchTab('resultTab')">结果确认</button>
            </div>
            
            <div id="uploadTab" class="tab-content active">
                <p>请上传QQ手气红包领取完毕的截图</p>
                <div class="upload-area" id="uploadArea">
                    <div style="text-align: center; padding: 30px; border: 2px dashed #ddd; border-radius: 10px; cursor: pointer;">
                        <div style="font-size: 3rem; margin-bottom: 15px;">📁</div>
                        <p>点击或拖拽上传QQ红包截图</p>
                        <p style="color: #888; font-size: 0.9rem;">建议使用清晰截图以提高识别准确率</p>
                    </div>
                </div>
                <input type="file" id="imageUpload" accept="image/*" style="display: none;">
                
                <div class="auto-mode">
                    <input type="checkbox" id="autoSave" checked>
                    <label for="autoSave">自动保存识别结果并分析推荐</label>
                </div>
                
                <div class="status-message">
                    <p><strong>提示：</strong>如果自动识别不准确，可以使用"手动输入"标签直接输入数据</p>
                </div>
                
                <div id="uploadStatus" class="status-message"></div>
                <button onclick="loadImageForAdjustment()">下一步：调整识别区域</button>
            </div>
            
            <div id="adjustTab" class="tab-content">
                <p>请调整识别区域，确保红色框完全覆盖金额信息</p>
                <div class="image-preview-container">
                    <img id="imagePreview" src="" alt="预览图片">
                    <!-- 识别区域框将通过JS动态添加 -->
                </div>
                
                <div class="control-panel">
                    <div class="control-group">
                        <h4>裁切区域调整</h4>
                        
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>左: <span id="cropLeftVal">70</span>%</span>
                            </div>
                            <input type="range" min="50" max="90" value="70" class="slider" id="cropLeft">
                        </div>
                        
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>宽: <span id="cropWidthVal">25</span>%</span>
                            </div>
                            <input type="range" min="10" max="40" value="25" class="slider" id="cropWidth">
                        </div>
                        
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>上: <span id="cropTopVal">15</span>%</span>
                            </div>
                            <input type="range" min="0" max="40" value="15" class="slider" id="cropTop">
                        </div>
                        
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>高: <span id="cropHeightVal">80</span>%</span>
                            </div>
                            <input type="range" min="50" max="100" value="80" class="slider" id="cropHeight">
                        </div>
                        
                        <div class="preset-buttons">
                            <button class="preset-button" onclick="setDefaultCrop()">自动裁切右侧列</button>
                        </div>
                    </div>
                </div>
                
                <div class="progress-bar">
                    <div class="progress" id="ocrProgress"></div>
                </div>
                
                <div class="enhanced-controls">
                    <button class="btn-secondary" id="enhancedOCRBtn">增强识别模式</button>
                    <button class="success" onclick="doEnhancedOCR()">开始识别</button>
                </div>
                
                <button onclick="switchTab('uploadTab')">上一步</button>
                <button onclick="switchTab('manualTab')">跳过识别，手动输入</button>
            </div>
            
            <div id="manualTab" class="tab-content">
                <div class="manual-input">
                    <h4>手动输入红包数据</h4>
                    <p>如果自动识别不准确，请在此直接输入正确数据</p>
                    
                    <div class="amount-input">
                        <label for="manualTotalAmount">总金额:</label>
                        <input type="number" step="0.01" id="manualTotalAmount" placeholder="例如: 5.00">
                    </div>
                    
                    <div class="amount-input">
                        <label for="manualPacketCount">红包个数:</label>
                        <input type="number" id="manualPacketCount" placeholder="例如: 9">
                    </div>
                    
                    <h4>每个红包金额 (请按顺序输入):</h4>
                    <div class="amount-inputs" id="manualAmountInputs">
                        <!-- 动态生成金额输入框 -->
                    </div>
                    
                    <button onclick="addAmountField()">添加金额字段</button>
                    <button onclick="removeAmountField()">删除最后一个金额字段</button>
                </div>
                
                <button class="success" onclick="saveManualData()">保存手动输入的数据</button>
                <button onclick="switchTab('adjustTab')">返回自动识别</button>
            </div>
            
            <div id="resultTab" class="tab-content">
                <h4>识别结果</h4>
                <div id="ocrResult"></div>
                
                <div id="amountListContainer" style="display: none;">
                    <h4>识别出的金额（可编辑） <span id="accuracyBadge" class="accuracy-badge" style="display: none;">准确率: 高</span></h4>
                    <div class="amount-list" id="amountList">
                        <div style="text-align: center; padding: 20px; color: #888;">无识别数据</div>
                    </div>
                </div>
                
                <div id="correctionArea"></div>
                <button class="success" onclick="saveData()">保存数据并预测</button>
                <button onclick="switchTab('adjustTab')">重新识别</button>
                <button onclick="switchTab('manualTab')">手动输入</button>
            </div>
            
            <button class="danger" onclick="closeUploadModal()" style="margin-top: 15px;">关闭</button>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <h1>🎯 QQ手气红包尾数预测系统 - 综合增强版</h1>
            <p>基于历史数据的智能尾数预测 + 增强OCR识别</p>
        </div>

        <!-- 当前数据展示 -->
        <div class="section">
            <h3>📊 最新红包数据</h3>
            <div id="currentData"></div>
        </div>

        <!-- 预测结果 -->
        <div class="section">
            <h3>🔮 预测结果</h3>
            <div id="predictionResult"></div>
            <div class="chart-container">
                <canvas id="tailDistributionChart"></canvas>
            </div>
        </div>

        <!-- 历史记录 -->
        <div class="section">
            <h3>📈 历史记录</h3>
            <div id="historyList"></div>
        </div>
    </div>

    <script>
        // 全局变量
        let redPacketHistory = JSON.parse(localStorage.getItem('redPacketHistory')) || [];
        let currentOCRData = null;
        let tailDistributionChart = null;
        let currentImage = null;
        let imageWidth = 0;
        let imageHeight = 0;
        let recognizedAmounts = [];
        
        // 初始化
        document.addEventListener('DOMContentLoaded', function() {
            updateHistoryDisplay();
            if (redPacketHistory.length > 0) {
                generatePrediction();
            }
            initializeManualInputs();
            setupSliders();
            setupUploadArea();
        });
        
        // 设置上传区域
        function setupUploadArea() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('imageUpload');
            
            uploadArea.addEventListener('click', () => fileInput.click());
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#667eea';
                uploadArea.style.backgroundColor = 'rgba(102, 126, 234, 0.05)';
            });
            uploadArea.addEventListener('dragleave', () => {
                uploadArea.style.borderColor = '#ddd';
                uploadArea.style.backgroundColor = '';
            });
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#ddd';
                uploadArea.style.backgroundColor = '';
                
                if (e.dataTransfer.files.length) {
                    fileInput.files = e.dataTransfer.files;
                    loadImageForAdjustment();
                }
            });
        }
        
        // 设置滑块事件监听
        function setupSliders() {
            // 裁切区域滑块
            document.getElementById('cropLeft').addEventListener('input', function() {
                document.getElementById('cropLeftVal').textContent = this.value;
                if (currentImage) drawCropOverlay();
            });
            
            document.getElementById('cropWidth').addEventListener('input', function() {
                document.getElementById('cropWidthVal').textContent = this.value;
                if (currentImage) drawCropOverlay();
            });
            
            document.getElementById('cropTop').addEventListener('input', function() {
                document.getElementById('cropTopVal').textContent = this.value;
                if (currentImage) drawCropOverlay();
            });
            
            document.getElementById('cropHeight').addEventListener('input', function() {
                document.getElementById('cropHeightVal').textContent = this.value;
                if (currentImage) drawCropOverlay();
            });
        }
        
        // 设置默认裁切
        function setDefaultCrop() {
            document.getElementById('cropLeft').value = 70;
            document.getElementById('cropWidth').value = 25;
            document.getElementById('cropTop').value = 15;
            document.getElementById('cropHeight').value = 80;
            
            document.getElementById('cropLeftVal').textContent = '70';
            document.getElementById('cropWidthVal').textContent = '25';
            document.getElementById('cropTopVal').textContent = '15';
            document.getElementById('cropHeightVal').textContent = '80';
            
            if (currentImage) drawCropOverlay();
        }
        
        // 绘制裁切覆盖层
        function drawCropOverlay() {
            if (!currentImage) return;
            
            const canvas = document.getElementById('imagePreview');
            const ctx = canvas.getContext('2d');
            
            // 清除并重绘图像
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
            
            // 计算裁切区域
            const leftP = parseInt(document.getElementById('cropLeft').value) / 100;
            const widthP = parseInt(document.getElementById('cropWidth').value) / 100;
            const topP = parseInt(document.getElementById('cropTop').value) / 100;
            const heightP = parseInt(document.getElementById('cropHeight').value) / 100;
            
            const x = canvas.width * leftP;
            const y = canvas.height * topP;
            const w = canvas.width * widthP;
            const h = canvas.height * heightP;
            
            // 绘制半透明覆盖层
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 清除裁切区域
            ctx.clearRect(x, y, w, h);
            
            // 绘制裁切区域边框
            ctx.strokeStyle = '#e54d42';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, w, h);
        }
        
        // 获取裁切后的图像
        function getCroppedImage() {
            if (!currentImage) return null;
            
            const leftP = parseInt(document.getElementById('cropLeft').value) / 100;
            const widthP = parseInt(document.getElementById('cropWidth').value) / 100;
            const topP = parseInt(document.getElementById('cropTop').value) / 100;
            const heightP = parseInt(document.getElementById('cropHeight').value) / 100;
            
            const sx = currentImage.width * leftP;
            const sy = currentImage.height * topP;
            const sw = currentImage.width * widthP;
            const sh = currentImage.height * heightP;
            
            // 创建临时Canvas进行裁切
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = sw;
            tempCanvas.height = sh;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.drawImage(currentImage, sx, sy, sw, sh, 0, 0, sw, sh);
            
            return tempCanvas.toDataURL('image/jpeg');
        }
        
        // 初始化手动输入框
        function initializeManualInputs() {
            const container = document.getElementById('manualAmountInputs');
            // 初始创建9个输入框（对应9个红包）
            for (let i = 0; i < 9; i++) {
                const div = document.createElement('div');
                div.className = 'amount-input';
                div.innerHTML = `
                    <label>红包${i+1}:</label>
                    <input type="number" step="0.01" class="manual-amount" placeholder="0.00">
                `;
                container.appendChild(div);
            }
        }
        
        // 添加金额输入框
        function addAmountField() {
            const container = document.getElementById('manualAmountInputs');
            const count = container.children.length;
            const div = document.createElement('div');
            div.className = 'amount-input';
            div.innerHTML = `
                <label>红包${count+1}:</label>
                <input type="number" step="0.01" class="manual-amount" placeholder="0.00">
            `;
            container.appendChild(div);
        }
        
        // 删除最后一个金额输入框
        function removeAmountField() {
            const container = document.getElementById('manualAmountInputs');
            if (container.children.length > 1) {
                container.removeChild(container.lastChild);
            }
        }
        
        // 标签切换
        function switchTab(tabName) {
            // 隐藏所有标签内容
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // 取消所有标签按钮的激活状态
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // 显示选中的标签内容
            document.getElementById(tabName).classList.add('active');
            
            // 激活对应的标签按钮
            event.target.classList.add('active');
        }
        
        // 上传模态框控制
        function openUploadModal() {
            document.getElementById('uploadModal').style.display = 'flex';
            switchTab('uploadTab');
            document.getElementById('uploadStatus').innerHTML = '';
        }

        function closeUploadModal() {
            document.getElementById('uploadModal').style.display = 'none';
            // 清理资源
            if (currentImage) {
                URL.revokeObjectURL(currentImage.src);
            }
        }
        
        // 加载图片用于调整识别区域
        function loadImageForAdjustment() {
            const fileInput = document.getElementById('imageUpload');
            if (!fileInput.files[0]) {
                showStatus('请先选择图片', 'error');
                return;
            }
            
            const file = fileInput.files[0];
            const imagePreview = document.getElementById('imagePreview');
            
            // 创建图片对象
            const img = new Image();
            img.onload = function() {
                currentImage = img;
                imageWidth = img.width;
                imageHeight = img.height;
                
                // 设置预览容器尺寸
                const container = imagePreview.parentElement;
                container.style.maxWidth = '100%';
                
                // 创建Canvas用于显示裁切区域
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                
                imagePreview.src = canvas.toDataURL('image/jpeg');
                
                // 切换到调整标签
                switchTab('adjustTab');
                
                // 绘制裁切覆盖层
                setTimeout(() => {
                    drawCropOverlay();
                }, 100);
            };
            
            img.src = URL.createObjectURL(file);
        }
        
        // 增强OCR识别
        async function doEnhancedOCR() {
            if (!currentImage) {
                showStatus('请先上传图片', 'error');
                return;
            }
            
            const btn = document.getElementById('enhancedOCRBtn');
            btn.disabled = true;
            btn.innerHTML = '<span class="loading"></span> 识别中...';
            showStatus('OCR识别中...', '');
            document.getElementById('ocrProgress').style.width = '0%';
            
            try {
                const imageData = getCroppedImage();
                
                // 增强模式：多次识别并取最佳结果
                const results = [];
                
                // 第一次识别
                updateProgress(0.2);
                const result1 = await Tesseract.recognize(imageData, 'chi_sim+eng', {
                    logger: m => {
                        if (m.status === 'recognizing text') {
                            updateProgress(0.2 + m.progress * 0.3);
                        }
                    }
                });
                results.push(result1);
                
                // 调整参数后第二次识别
                updateProgress(0.6);
                const result2 = await Tesseract.recognize(imageData, 'chi_sim+eng', {
                    tessjs_create_tsv: '1',
                    tessjs_create_box: '1',
                    tessjs_create_unlv: '1',
                    logger: m => {
                        if (m.status === 'recognizing text') {
                            updateProgress(0.6 + m.progress * 0.2);
                        }
                    }
                });
                results.push(result2);
                
                // 选择置信度最高的结果
                const bestResult = results.reduce((best, current) => 
                    current.data.confidence > best.data.confidence ? current : best
                );
                
                const text = bestResult.data.text;
                const words = bestResult.data.words;
                
                updateProgress(1);
                
                // 提取金额
                extractAmountsFromOCR(text, words);
                
                // 如果开启了自动模式，自动保存并分析
                if (document.getElementById('autoSave').checked) {
                    setTimeout(saveData, 500);
                }
                
            } catch (error) {
                console.error('OCR Error:', error);
                showStatus('识别失败: ' + error.message, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = '增强识别模式';
                setTimeout(() => { document.getElementById('ocrProgress').style.width = '0%'; }, 1000);
            }
        }
        
        // 更新进度条
        function updateProgress(progress) {
            const percent = progress * 100;
            document.getElementById('ocrProgress').style.width = `${percent}%`;
        }
        
        // 从OCR结果中提取金额
        function extractAmountsFromOCR(text, words) {
            // 方法1: 从识别的文本中提取金额
            const amountRegex = /(\d+\.\d{2})元?/g;
            const matches = [...text.matchAll(amountRegex)];
            const amountsFromText = matches.map(m => parseFloat(m[1])).filter(a => a >= 0.01 && a < 1000);
            
            // 方法2: 从单词中提取数字
            const numericWords = [];
            const numRegex = /(\d+\.\d{2}|\d+)/;
            
            if (words) {
                words.forEach(word => {
                    const match = word.text.match(numRegex);
                    if (match && !word.text.includes(':') && word.confidence > 50) {
                        const value = parseFloat(match[1]);
                        if (!isNaN(value) && value >= 0.01 && value < 1000) {
                            numericWords.push({
                                value: value,
                                text: word.text,
                                confidence: word.confidence
                            });
                        }
                    }
                });
            }
            
            // 优先使用从文本中提取的金额，如果没有则使用从单词中提取的
            if (amountsFromText.length >= numericWords.length) {
                recognizedAmounts = amountsFromText.map(value => ({ value }));
            } else {
                recognizedAmounts = numericWords;
            }
            
            // 如果仍然没有识别到金额，尝试更宽松的匹配
            if (recognizedAmounts.length === 0) {
                const fallbackMatches = text.match(/\d+\.\d{2}/g) || [];
                recognizedAmounts = fallbackMatches.map(value => ({ value: parseFloat(value) }))
                    .filter(a => a.value >= 0.01 && a.value < 1000);
            }
            
            if (recognizedAmounts.length === 0) {
                showStatus('未识别到任何金额，请调整裁切区域或尝试更清晰的图片', 'error');
                return;
            }
            
            // 显示识别结果
            renderAmountList();
            computeAndShowTails();
            
            // 准备数据
            prepareOCRData();
            
            // 切换到结果标签
            switchTab('resultTab');
            showStatus('识别完成！请核对结果', 'success');
        }
        
        // 渲染金额列表
        function renderAmountList() {
            const amountList = document.getElementById('amountList');
            amountList.innerHTML = '';
            
            if (!recognizedAmounts.length) {
                amountList.innerHTML = '<div style="text-align: center; padding: 20px; color: #888;">无识别数据</div>';
                return;
            }
            
            recognizedAmounts.forEach((amount, index) => {
                const item = document.createElement('div');
                item.className = 'amount-item';
                if (amount.anomaly) {
                    item.style.backgroundColor = '#ffebee';
                }
                item.innerHTML = `
                    <div>
                        <input type="number" step="0.01" min="0.01" value="${amount.value.toFixed(2)}" 
                            data-index="${index}" style="width: 80px; padding: 5px; border: 1px solid #ddd; border-radius: 4px;${amount.anomaly ? ' border-color: #f44336;' : ''}">
                        元
                        ${amount.anomaly ? `<div style="font-size: 0.8rem; color: #f44336;">建议: ${amount.suggested.toFixed(2)}</div>` : ''}
                    </div>
                    <div>
                        <button class="btn-small btn-outline" data-remove="${index}">删除</button>
                    </div>
                `;
                amountList.appendChild(item);
                
                // 添加事件监听
                item.querySelector('input').addEventListener('change', (e) => {
                    const idx = parseInt(e.target.getAttribute('data-index'));
                    const newValue = parseFloat(e.target.value);
                    if (!isNaN(newValue) && newValue > 0) {
                        recognizedAmounts[idx].value = newValue;
                        recognizedAmounts[idx].anomaly = false; // 修正后移除异常标记
                        computeAndShowTails();
                        prepareOCRData(); // 重新准备数据
                    }
                });
                
                item.querySelector('[data-remove]').addEventListener('click', (e) => {
                    const idx = parseInt(e.target.getAttribute('data-remove'));
                    recognizedAmounts.splice(idx, 1);
                    renderAmountList();
                    computeAndShowTails();
                    prepareOCRData(); // 重新准备数据
                });
            });
            
            // 显示金额列表容器
            document.getElementById('amountListContainer').style.display = 'block';
        }
        
        // 计算并显示尾数
        function computeAndShowTails() {
            if (!recognizedAmounts.length) return;
            
            // 计算尾数分布
            const tailCount = {};
            let totalAmount = 0;
            
            recognizedAmounts.forEach(amount => {
                totalAmount += amount.value;
                // 获取分的最后一位数字
                const cents = Math.round(amount.value * 100);
                const tail = cents % 10;
                tailCount[tail] = (tailCount[tail] || 0) + 1;
            });
            
            // 显示结果
            const ocrResult = document.getElementById('ocrResult');
            let html = `
                <div class="result-card">
                    <p><strong>识别结果:</strong></p>
                    <p>识别到 <strong>${recognizedAmounts.length}</strong> 个红包，总计 <strong>${totalAmount.toFixed(2)}</strong> 元</p>
                    <p><strong>尾数分布:</strong></p>
            `;
            
            // 按出现次数排序
            const sortedTails = Object.entries(tailCount)
                .sort((a, b) => b[1] - a[1])
                .map(([tail, count]) => {
                    const percentage = (count / recognizedAmounts.length * 100).toFixed(1);
                    return `<span class="tail-tag">${tail} (${count}次, ${percentage}%)</span>`;
                });
            
            html += sortedTails.join(' ') + '</div>';
            ocrResult.innerHTML = html;
        }
        
        // 准备OCR数据
        function prepareOCRData() {
            if (!recognizedAmounts.length) return;
            
            const totalAmount = recognizedAmounts.reduce((sum, item) => sum + item.value, 0);
            const packetCount = recognizedAmounts.length;
            
            // 计算尾数
            const tails = recognizedAmounts.map(amount => {
                const cents = Math.round(amount.value * 100);
                return cents % 10;
            });
            
            currentOCRData = {
                timestamp: new Date().toISOString(),
                totalAmount,
                packetCount,
                amounts: recognizedAmounts.map(a => a.value),
                tails,
                rawText: "OCR识别数据"
            };
        }
        
        // 保存手动输入的数据
        function saveManualData() {
            const totalAmount = parseFloat(document.getElementById('manualTotalAmount').value);
            const packetCount = parseInt(document.getElementById('manualPacketCount').value);
            
            if (isNaN(totalAmount) || totalAmount <= 0) {
                showStatus('请输入正确的总金额', 'error');
                return;
            }
            
            if (isNaN(packetCount) || packetCount <= 0) {
                showStatus('请输入正确的红包个数', 'error');
                return;
            }
            
            // 获取所有手动输入的金额
            const amountInputs = document.querySelectorAll('.manual-amount');
            const amounts = [];
            
            for (let i = 0; i < amountInputs.length; i++) {
                const amount = parseFloat(amountInputs[i].value);
                if (!isNaN(amount) && amount > 0) {
                    amounts.push(amount);
                }
            }
            
            if (amounts.length === 0) {
                showStatus('请至少输入一个有效的金额', 'error');
                return;
            }
            
            // 计算尾数
            const tails = amounts.map(amount => {
                const cents = Math.round(amount * 100) % 10;
                return cents;
            });
            
            currentOCRData = {
                timestamp: new Date().toISOString(),
                totalAmount,
                packetCount,
                amounts,
                tails,
                rawText: "手动输入数据",
                isManual: true
            };
            
            // 显示识别结果
            displayOCRResult(currentOCRData);
            openCorrectionInterface(currentOCRData);
            
            // 切换到结果标签
            switchTab('resultTab');
            showStatus('手动输入数据已加载，请确认后保存', 'success');
        }
        
        // 显示OCR识别结果
        function displayOCRResult(data) {
            const ocrResult = document.getElementById('ocrResult');
            ocrResult.innerHTML = `
                <div class="result-card">
                    <p><strong>${data.isManual ? '手动输入' : '识别'}结果:</strong></p>
                    <p>总金额: ${data.totalAmount.toFixed(2)}元</p>
                    <p>红包个数: ${data.packetCount}个</p>
                    <p>金额列表: ${data.amounts.map(a => a.toFixed(2)).join(', ')}</p>
                    <p>尾数: ${data.tails.join(', ')}</p>
                </div>
            `;
        }
        
        // 打开校正界面
        function openCorrectionInterface(data) {
            const correctionArea = document.getElementById('correctionArea');
            correctionArea.innerHTML = `
                <div class="result-card">
                    <h4>请核对${data.isManual ? '手动输入' : '识别'}结果，如有错误请修改:</h4>
                    <p>总金额: <input type="number" step="0.01" id="correctTotalAmount" value="${data.totalAmount}"> 元</p>
                    <p>红包个数: <input type="number" id="correctPacketCount" value="${data.packetCount}"> 个</p>
                    <div id="amountCorrections">
                        ${data.amounts.map((amount, index) => `
                            <p>红包${index+1}: <input type="number" step="0.01" value="${amount.toFixed(2)}" data-index="${index}"> 元</p>
                        `).join('')}
                    </div>
                    <button class="success" onclick="saveCorrectedData()">保存校正后的数据</button>
                </div>
            `;
        }
        
        // 保存校正后的数据
        function saveCorrectedData() {
            if (!currentOCRData) return;
            
            // 获取校正后的值
            const correctedTotalAmount = parseFloat(document.getElementById('correctTotalAmount').value) || currentOCRData.totalAmount;
            const correctedPacketCount = parseInt(document.getElementById('correctPacketCount').value) || currentOCRData.packetCount;
            
            // 获取校正后的每个红包金额
            const correctedAmounts = [];
            const amountInputs = document.querySelectorAll('#amountCorrections input');
            amountInputs.forEach(input => {
                const amount = parseFloat(input.value);
                if (!isNaN(amount) && amount > 0) {
                    correctedAmounts.push(amount);
                }
            });
            
            // 更新数据
            currentOCRData.totalAmount = correctedTotalAmount;
            currentOCRData.packetCount = correctedPacketCount;
            currentOCRData.amounts = correctedAmounts;
            currentOCRData.tails = correctedAmounts.map(amount => Math.round(amount * 100) % 10);
            
            saveData();
        }
        
        // 保存数据
        function saveData() {
            if (!currentOCRData) return;
            
            // 添加到历史记录
            redPacketHistory.push(currentOCRData);
            localStorage.setItem('redPacketHistory', JSON.stringify(redPacketHistory));
            
            // 更新显示
            updateHistoryDisplay();
            generatePrediction();
            displayCurrentData(currentOCRData);
            
            showStatus('数据保存成功！预测结果已更新', 'success');
            setTimeout(() => {
                closeUploadModal();
            }, 1500);
        }
        
        // 显示状态消息
        function showStatus(message, type) {
            const statusElement = document.getElementById('uploadStatus');
            statusElement.textContent = message;
            statusElement.className = 'status-message';
            
            if (type === 'error') {
                statusElement.classList.add('error');
            } else if (type === 'success') {
                statusElement.classList.add('success');
            }
        }
        
        // 更新历史记录显示
        function updateHistoryDisplay() {
            const historyList = document.getElementById('historyList');
            
            if (redPacketHistory.length === 0) {
                historyList.innerHTML = '<p>暂无历史记录，请上传第一个红包截图</p>';
                return;
            }
            
            historyList.innerHTML = redPacketHistory.slice().reverse().map((record, index) => `
                <div class="history-item">
                    <p><strong>记录 ${redPacketHistory.length - index}</strong> - 
                       ${new Date(record.timestamp).toLocaleString()} - 
                       总金额: ${record.totalAmount.toFixed(2)}元</p>
                    <p>金额列表: ${record.amounts.map(a => a.toFixed(2)).join(', ')}</p>
                    <p>尾数: ${record.tails.join(', ')}</p>
                    <button class="correct-btn" onclick="reanalyzeRecord(${redPacketHistory.length - 1 - index})">重新分析</button>
                </div>
            `).join('');
        }
        
        // 显示当前数据
        function displayCurrentData(data) {
            const currentDataDiv = document.getElementById('currentData');
            currentDataDiv.innerHTML = `
                <div class="result-card">
                    <p><strong>总金额:</strong> ${data.totalAmount.toFixed(2)}元</p>
                    <p><strong>红包个数:</strong> ${data.packetCount}个</p>
                    <p><strong>金额列表:</strong> ${data.amounts.map(a => a.toFixed(2)).join(', ')}</p>
                    <p><strong>尾数:</strong> ${data.tails.join(', ')}</p>
                </div>
            `;
        }
        
        // 高级预测算法（基于历史数据）- 来自008程序
        function advancedPredictionWithHistory() {
            if (redPacketHistory.length === 0) return [3, 6, 9]; // 默认值
            
            const currentData = redPacketHistory[redPacketHistory.length - 1];
            const allTails = redPacketHistory.flatMap(record => record.tails);
            
            // 多维度分析
            const predictions = {
                // 方法1: 频率加权分析
                frequencyWeighted: frequencyWeightedAnalysis(allTails),
                
                // 方法2: 时间序列分析
                timeSeries: timeSeriesAnalysis(redPacketHistory),
                
                // 方法3: 模式识别分析
                patternRecognition: patternRecognitionAnalysis(redPacketHistory),
                
                // 方法4: 概率偏差分析
                probabilityBias: probabilityBiasAnalysis(allTails)
            };
            
            // 综合评分
            return comprehensiveScoring(predictions);
        }
        
        // 频率加权分析
        function frequencyWeightedAnalysis(allTails) {
            const freq = {};
            allTails.forEach(tail => {
                freq[tail] = (freq[tail] || 0) + 1;
            });
            
            // 按频率排序，选择前3个
            return Object.keys(freq)
                .sort((a, b) => freq[b] - freq[a])
                .slice(0, 3)
                .map(Number);
        }
        
        // 时间序列分析
        function timeSeriesAnalysis(history) {
            if (history.length < 2) return [0, 1, 2]; // 默认值
            
            const recentTails = history.slice(-5).flatMap(record => record.tails);
            const changes = [];
            
            for (let i = 1; i < recentTails.length; i++) {
                changes.push((recentTails[i] - recentTails[i-1] + 10) % 10);
            }
            
            const avgChange = changes.reduce((a, b) => a + b, 0) / changes.length;
            const lastTail = recentTails[recentTails.length - 1];
            const predicted = Math.round((lastTail + avgChange) % 10);
            
            return [predicted, (predicted + 3) % 10, (predicted + 7) % 10];
        }
        
        // 模式识别分析
        function patternRecognitionAnalysis(history) {
            // 分析历史中的尾数组合模式
            const tailPatterns = [];
            
            for (let i = 0; i < history.length - 1; i++) {
                tailPatterns.push({
                    previous: history[i].tails,
                    next: history[i+1].tails
                });
            }
            
            // 简化版：寻找最近相似模式
            if (tailPatterns.length === 0) return [3, 6, 9];
            
            const currentTails = history[history.length - 1].tails;
            let bestMatch = tailPatterns[0];
            let minDifference = Infinity;
            
            tailPatterns.forEach(pattern => {
                const diff = calculateTailDifference(pattern.previous, currentTails);
                if (diff < minDifference) {
                    minDifference = diff;
                    bestMatch = pattern;
                }
            });
            
            return [...new Set(bestMatch.next)].slice(0, 3);
        }
        
        // 概率偏差分析
        function probabilityBiasAnalysis(allTails) {
            const total = allTails.length;
            const expectedProb = 0.1; // 每个尾数理论概率10%
            const deviations = {};
            
            for (let i = 0; i < 10; i++) {
                const actualCount = allTails.filter(tail => tail === i).length;
                const actualProb = actualCount / total;
                deviations[i] = Math.abs(actualProb - expectedProb);
            }
            
            // 选择偏差最大的（最可能回归平均）
            return Object.keys(deviations)
                .sort((a, b) => deviations[b] - deviations[a])
                .slice(0, 3)
                .map(Number);
        }
        
        // 综合评分算法
        function comprehensiveScoring(predictions) {
            const scoreMap = {};
            const methods = Object.values(predictions);
            
            methods.forEach(method => {
                method.forEach((tail, index) => {
                    const score = 3 - index; // 排名越高分数越高
                    scoreMap[tail] = (scoreMap[tail] || 0) + score;
                });
            });
            
            // 按综合得分排序，选择前3个
            return Object.keys(scoreMap)
                .sort((a, b) => scoreMap[b] - scoreMap[a])
                .slice(0, 3)
                .map(Number);
        }
        
        // 计算尾数差异
        function calculateTailDifference(tails1, tails2) {
            // 简化差异计算
            return Math.abs(tails1.reduce((a, b) => a + b, 0) - tails2.reduce((a, b) => a + b, 0));
        }
        
        // 生成预测
        function generatePrediction() {
            if (redPacketHistory.length === 0) return;
            
            const prediction = advancedPredictionWithHistory();
            const currentData = redPacketHistory[redPacketHistory.length - 1];
            
            // 计算置信度
            const confidence = redPacketHistory.length < 3 ? 'low' : 
                              redPacketHistory.length < 10 ? 'medium' : 'high';
            
            // 显示预测结果
            const predictionResult = document.getElementById('predictionResult');
            predictionResult.innerHTML = `
                <div class="prediction-result">
                    <h3>🎯 下一次红包预测结果</h3>
                    <p>基于 <strong>${redPacketHistory.length}</strong> 条历史记录分析</p>
                    <p>推荐金额: <strong>${currentData.totalAmount.toFixed(2)}元</strong> (${currentData.packetCount}个包)</p>
                    <p>预测尾数: </p>
                    <div>
                        ${prediction.map(tail => `<span class="tail-number">${tail}</span>`).join('')}
                    </div>
                    <p>置信度: <span class="confidence-${confidence}">${confidence === 'high' ? '高' : confidence === 'medium' ? '中' : '低'}</span></p>
                </div>
            `;
            
            // 更新图表
            updateTailDistributionChart();
        }
        
        // 更新尾数分布图表
        function updateTailDistributionChart() {
            const allTails = redPacketHistory.flatMap(record => record.tails);
            const tailCounts = Array(10).fill(0);
            
            allTails.forEach(tail => {
                tailCounts[tail]++;
            });
            
            const ctx = document.getElementById('tailDistributionChart').getContext('2d');
            
            if (tailDistributionChart) {
                tailDistributionChart.destroy();
            }
            
            tailDistributionChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
                    datasets: [{
                        label: '尾数出现次数',
                        data: tailCounts,
                        backgroundColor: 'rgba(102, 126, 234, 0.7)',
                        borderColor: 'rgba(102, 126, 234, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: '出现次数'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: '尾数'
                            }
                        }
                    }
                }
            });
        }
        
        // 重新分析记录
        function reanalyzeRecord(index) {
            const record = redPacketHistory[index];
            currentOCRData = {...record};
            displayOCRResult(currentOCRData);
            openCorrectionInterface(currentOCRData);
            
            // 打开上传模态框并切换到结果标签
            openUploadModal();
            switchTab('resultTab');
        }
    </script>
</body>
</html>